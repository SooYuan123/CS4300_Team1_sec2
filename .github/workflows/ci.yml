name: CI Pipeline with AI Review

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  test-and-coverage:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for better AI context

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install coverage pytest pytest-django pytest-cov

    - name: Run migrations
      run: |
        python manage.py migrate --settings=CelestiaTrack.settings_ci

    - name: Run tests with coverage
      run: |
        # Measure coverage for application code only (excludes migrations, venv, etc.)
        # Add more apps here as your project grows: --source='home,CelestiaTrack,newapp'
        coverage run --source='home,CelestiaTrack' manage.py test --settings=CelestiaTrack.settings_ci
        coverage xml

    - name: Check coverage threshold
      run: |
        # Fail if coverage is below threshold to maintain code quality
        # Default is 80%, can be configured by setting COVERAGE_THRESHOLD env var
        coverage report | tee coverage-report.txt
        coverage report --fail-under=${COVERAGE_THRESHOLD:-80}

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage.xml
          coverage-report.txt

    - name: Comment coverage on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const coverage = fs.readFileSync('coverage-report.txt', 'utf8');
          const comment = `## Coverage Report\n\`\`\`\n${coverage}\n\`\`\``;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  ai-code-review:
    runs-on: ubuntu-latest
    needs: [test-and-coverage]  # Only run if tests pass
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history to handle multiple commits in PR

    - name: Get changed files
      id: changed-files
      run: |
        git fetch origin ${{ github.base_ref }}
        CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD || echo "")
        echo "files<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: AI Code Review with ChatGPT
      if: steps.changed-files.outputs.files != ''
      uses: actions/github-script@v7
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        # Hardcode a model with >= 32k context or one you know exists; override via repo/org vars if needed.
        OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}
      with:
        script: |
          const { execSync } = require('child_process');

          // 1) Filter to code-like files and cap the number of files
          const ALL = `${{ steps.changed-files.outputs.files }}`.split('\n').filter(Boolean);
          const CODE_EXT = /\.(py|js|jsx|ts|tsx|css|scss|html|json|yml|yaml|md)$/i;
          let FILES = ALL.filter(f => CODE_EXT.test(f));
          const MAX_FILES = 25;
          if (FILES.length > MAX_FILES) FILES = FILES.slice(0, MAX_FILES);

          if (FILES.length === 0) {
            console.log('No relevant code files changed.');
            return;
          }

          // 2) Build diffs with strict caps
          const PER_FILE_MAX_LINES = 120;         // tighter per-file cap
          const MAX_CHARS = 6000;                 // hard cap for total prompt (~1.5k tokens)
          const CHUNK_SIZE = 2400;                // per chunk (~600 tokens)
          const diffs = [];

          for (const file of FILES) {
            try {
              const raw = execSync(`git diff --unified=2 origin/${{ github.base_ref }}...HEAD -- ${file}`, {encoding: 'utf8'});
              if (!raw.trim()) continue;
              const lines = raw.split('\n');
              const head = lines.slice(0, PER_FILE_MAX_LINES).join('\n');
              diffs.push(`### ${file}\n${head}${lines.length > PER_FILE_MAX_LINES ? '\n... (truncated)' : ''}`);
            } catch {
              console.log(`Could not get diff for ${file}`);
            }
          }

          if (diffs.length === 0) {
            console.log('No diffs produced after filtering.');
            return;
          }

          let diffContent = diffs.join('\n\n');
          if (diffContent.length > MAX_CHARS) {
            // keep the most recent tail since it often contains latest hunks
            diffContent = diffContent.slice(-MAX_CHARS);
          }

          async function chat(messages, maxTokens=500, temperature=0.2) {
            const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
            const resp = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
              },
              body: JSON.stringify({ model, messages, max_tokens: maxTokens, temperature }),
            });
            const data = await resp.json();
            if (!resp.ok) {
              console.error('OpenAI API error:', data);
              throw new Error(`OpenAI API failed: ${data.error?.message || 'Unknown error'}`);
            }
            return data.choices[0].message.content;
          }

          const systemPrompt =
            'You are an expert code reviewer. Provide concise, actionable bullets on: ' +
            '1) Potential bugs, 2) Security, 3) Performance, 4) Code style/best practices, 5) Missing tests. ' +
            'Cite files/lines if possible. Keep it short.';

          // Chunk helper
          function chunk(s, n) { const out=[]; for (let i=0;i<s.length;i+=n) out.push(s.slice(i,i+n)); return out; }
          const parts = chunk(diffContent, CHUNK_SIZE);

          let reviewText = '';
          try {
            if (parts.length === 1) {
              reviewText = await chat([
                { role: 'system', content: systemPrompt },
                { role: 'user', content: `Review these changes:\n${parts[0]}` },
              ], 500, 0.2);
            } else {
              const partials = [];
              for (let i=0;i<parts.length;i++) {
                const res = await chat([
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: `Part ${i+1}/${parts.length}:\n${parts[i]}` },
                ], 400, 0.2);
                partials.push(`### Part ${i+1}\n${res}`);
              }
              const merged = partials.join('\n\n');
              reviewText = await chat([
                { role: 'system', content: systemPrompt },
                { role: 'user', content: `Combine the following into one succinct, non-repetitive review:\n${merged}` },
              ], 600, 0.2);
            }
          } catch (e) {
            // If we still hit limits or any API error, post a graceful note and stop failing the job
            const note = 'Diff too large or API limit reached; posting a minimal summary.\n\n' +
                         '- Consider reviewing file-by-file or narrowing the PR scope.\n' +
                         '- The CI has trimmed diffs aggressively to avoid token overflows.';
            reviewText = note + `\n\n(Error details: ${e.message})`;
          }

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## AI Code Review\n\n${reviewText}\n\n---\n*Automated review*`
          });

  lint:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install linting tools
      run: |
        pip install flake8 pylint black isort

    - name: Run flake8
      continue-on-error: true
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics > flake8-report.txt

    - name: Run pylint
      continue-on-error: true
      run: |
        pylint **/*.py --exit-zero > pylint-report.txt || true

    - name: Upload lint reports
      uses: actions/upload-artifact@v4
      with:
        name: lint-reports
        path: |
          flake8-report.txt
          pylint-report.txt